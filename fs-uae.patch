diff --git a/Makefile.am b/Makefile.am
index 62132d7c..4beea729 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -171,6 +171,10 @@ fs_uae_SOURCES = \
 	src/fsuae/fsuae-options.h \
 	src/fsuae/fsuae-oskeyboard.c \
 	src/fsuae/fsuae-oskeyboard.h \
+	src/fsuae/fsuae-handler.c \
+	src/fsuae/fsuae-handler.h \
+	src/fsuae/fsuae-ini-exec.c \
+	src/fsuae/fsuae-ini-exec.h \
 	src/fsuae/fsuae-path.c \
 	src/fsuae/fsuae-path.h \
 	src/fsuae/fsuae-plugins.c \
diff --git a/fsemu/src/fsemu-action.c b/fsemu/src/fsemu-action.c
index 6226031b..95251c33 100644
--- a/fsemu/src/fsemu-action.c
+++ b/fsemu/src/fsemu-action.c
@@ -29,9 +29,12 @@ void fsemu_action_process_non_emu(fsemu_action_t action,
 {
     fsemu_thread_assert_main();
 
+    const char *value = fs_config_get_const_string("disable_on_screen_keyboard");
+    bool disable_on_screen_keyboard = value ? !!atoi(value) : false;
+
     printf("fsemu_action_process_non_emu %04x %04x\n", action, state);
 
-    if (action == FSEMU_ACTION_OSKEYBOARD) {
+    if (action == FSEMU_ACTION_OSKEYBOARD && !disable_on_screen_keyboard) {
         if (state) {
             fsemu_oskeyboard_toggle_open();
         }
diff --git a/fsemu/src/fsemu-action.h b/fsemu/src/fsemu-action.h
index ac4073b1..b8fb95a1 100644
--- a/fsemu/src/fsemu-action.h
+++ b/fsemu/src/fsemu-action.h
@@ -34,6 +34,7 @@ typedef int32_t fsemu_action_and_state_t;
 // #define FSEMU_ACTION_OSMENU 0x0002
 
 // #define FSEMU_DEFINE_ACTION()
+const char *fs_config_get_const_string(const char *key);
 
 void fsemu_action_post_from_main(uint16_t action);
 void fsemu_action_post_from_main_with_state(uint16_t action, int16_t state);
diff --git a/fsemu/src/fsemu-sdlwindow.c b/fsemu/src/fsemu-sdlwindow.c
index 97dc8df8..bffbc2b4 100644
--- a/fsemu/src/fsemu-sdlwindow.c
+++ b/fsemu/src/fsemu-sdlwindow.c
@@ -64,6 +64,8 @@ static struct {
     SDL_Cursor *size_nwse_cursor;
 
     bool no_event_polling;
+    bool disable_f12_key;
+    bool disable_mod_key;
 } fsemu_sdlwindow;
 
 // ---------------------------------------------------------------------------
@@ -786,13 +788,15 @@ bool fsemu_sdlwindow_handle_event(SDL_Event *event)
         mod_press_only = false;
         f12_press_only = false;
         // fsemu_window_log("SDL_KEYDOWN\n");
-        if (event->key.keysym.scancode == SDL_SCANCODE_F12) {
+        if (event->key.keysym.scancode == SDL_SCANCODE_F12 &&
+            !fsemu_sdlwindow.disable_f12_key) {
             fsemu_sdlwindow.f12_pressed = event->key.state != 0;
             f12_press_only = true;
         }
 
         if (!fsemu_sdlwindow.full_keyboard_emulation &&
-            event->key.keysym.scancode == FSEMU_KMOD_SCANCODE) {
+            event->key.keysym.scancode == FSEMU_KMOD_SCANCODE &&
+            !fsemu_sdlwindow.disable_mod_key) {
             fsemu_window_log("MOD key pressed\n");
             mod_press_only = true;
         }
@@ -1159,6 +1163,8 @@ static void fsemu_sdlwindow_quit(void)
 
 void fsemu_sdlwindow_init(void)
 {
+    const char *value;
+
     if (fsemu_sdlwindow.initialized) {
         return;
     }
@@ -1204,6 +1210,12 @@ void fsemu_sdlwindow_init(void)
     // One would think the default value was 0 already, but this does not
     // seem to always be the case.
     fsemu_sdlwindow.swap_interval = -1337;
+
+    value = fs_config_get_const_string("disable_f12_key");
+    fsemu_sdlwindow.disable_f12_key = value ? !!atoi(value) : false;
+
+    value = fs_config_get_const_string("disable_mod_key");
+    fsemu_sdlwindow.disable_mod_key = value ? !!atoi(value) : false;
 }
 
 #endif  // FSEMU_SDL
diff --git a/fsemu/src/fsemu-sdlwindow.h b/fsemu/src/fsemu-sdlwindow.h
index dadaf917..606bed33 100644
--- a/fsemu/src/fsemu-sdlwindow.h
+++ b/fsemu/src/fsemu-sdlwindow.h
@@ -19,6 +19,8 @@
 extern "C" {
 #endif
 
+const char *fs_config_get_const_string(const char *key);
+
 // This function can be called before fsemu_window_init and
 // fsemu_sdlwindow_init.
 void fsemu_sdlwindow_set_no_event_polling(bool no_event_polling);
diff --git a/fsemu/src/fsemu-startupinfo.c b/fsemu/src/fsemu-startupinfo.c
index 9d9b1e3e..a390d036 100644
--- a/fsemu/src/fsemu-startupinfo.c
+++ b/fsemu/src/fsemu-startupinfo.c
@@ -96,12 +96,12 @@ void fsemu_startupinfo_init(void)
         fsemu_fontcache_font("Fonts/SairaCondensed-Regular.ttf", 24);
 #endif
 
-    int x = 240;
+    // int x = 240;
     const char *string;
     // fsemu_image_t *image;
     uint32_t white = FSEMU_RGB(0xffffff);
     uint32_t white_2 = FSEMU_RGBA(0xffffffd0);
-    uint32_t white_3 = FSEMU_RGBA(0xffffffc0);
+    // uint32_t white_3 = FSEMU_RGBA(0xffffffc0);
 
 #if 0
     if (fsemu_option_read_const_string(FSEMU_OPTION_GAME_COVER, &string)) {
@@ -255,30 +255,30 @@ void fsemu_startupinfo_init(void)
     }
 #endif
 
-
-    x = 30;
-
-    item = &fsemu_startupinfo.menu_shortcut_text_item;
-    image = fsemu_font_render_text_to_image(font_3, "MENU KEY:", white_3);
-    fsemu_gui_image(item,
-                    x,
-                    1080 - 60 + (60 - image->height) / 2,
-                    image->width,
-                    image->height,
-                    image);
-    item->coordinates = FSEMU_COORD_1080P_LEFT;
-    item->z_index = 5001;
-    fsemu_gui_add_item(item);
-    x += image->width;
-
-    x += 15;
-
-    item = &fsemu_startupinfo.menu_shortcut_key_item;
-    image = fsemu_image_load("Images/ShortcutKeyAlt.png");
-    fsemu_gui_image(item, x, 1080 - 60, image->width, image->height, image);
-    item->coordinates = FSEMU_COORD_1080P_LEFT;
-    item->z_index = 5001;
-    fsemu_gui_add_item(item);
+    // disable MENU KEY info
+    // x = 30;
+
+    // item = &fsemu_startupinfo.menu_shortcut_text_item;
+    // image = fsemu_font_render_text_to_image(font_3, "MENU KEY:", white_3);
+    // fsemu_gui_image(item,
+    //                 x,
+    //                 1080 - 60 + (60 - image->height) / 2,
+    //                 image->width,
+    //                 image->height,
+    //                 image);
+    // item->coordinates = FSEMU_COORD_1080P_LEFT;
+    // item->z_index = 5001;
+    // fsemu_gui_add_item(item);
+    // x += image->width;
+
+    // x += 15;
+
+    // item = &fsemu_startupinfo.menu_shortcut_key_item;
+    // image = fsemu_image_load("Images/ShortcutKeyAlt.png");
+    // fsemu_gui_image(item, x, 1080 - 60, image->width, image->height, image);
+    // item->coordinates = FSEMU_COORD_1080P_LEFT;
+    // item->z_index = 5001;
+    // fsemu_gui_add_item(item);
 }
 
 static void fsemu_startupinfo_set_visible(bool visible)
diff --git a/src/fsuae/fsuae-consts.h b/src/fsuae/fsuae-consts.h
new file mode 100644
index 00000000..6e1e3615
--- /dev/null
+++ b/src/fsuae/fsuae-consts.h
@@ -0,0 +1,8 @@
+#ifndef FSUAE_CONSTS_H_
+#define FSUAE_CONSTS_H_
+
+#define TMP_INI_FILE "fs-uae.tmp.ini"
+#define MAX_LINE_LENGTH 1024
+#define APP_NAME "BERRYMIGA"
+
+#endif  // FSUAE_CONSTS_H_
diff --git a/src/fsuae/fsuae-externals.h b/src/fsuae/fsuae-externals.h
new file mode 100644
index 00000000..43050928
--- /dev/null
+++ b/src/fsuae/fsuae-externals.h
@@ -0,0 +1,9 @@
+#ifndef FSUAE_EXTERNALS_H_
+#define FSUAE_EXTERNALS_H_
+
+#include "uae/types.h"
+
+void ext_disk_eject(int num);
+void ext_disk_insert_force(int num, const char *name, bool forcedwriteprotect);
+
+#endif  // FSUAE_EXTERNALS_H_
diff --git a/src/fsuae/fsuae-handler.c b/src/fsuae/fsuae-handler.c
new file mode 100644
index 00000000..b6c842bb
--- /dev/null
+++ b/src/fsuae/fsuae-handler.c
@@ -0,0 +1,21 @@
+#define FSUAE_INTERNAL
+#include "fsuae-handler.h"
+#include "fsuae-ini-exec.h"
+#include "fsuae-consts.h"
+
+#include <stdio.h>
+#include <signal.h>
+#include <unistd.h>
+
+
+void SIGUSR1_handler(int signum)
+{
+    execute_ini_file(TMP_INI_FILE);
+}
+
+void fsuae_handlers_init(void)
+{
+    printf("[FSUAE] fsuae_handlers_init\n");
+
+    signal(SIGUSR1, SIGUSR1_handler);
+}
diff --git a/src/fsuae/fsuae-handler.h b/src/fsuae/fsuae-handler.h
new file mode 100644
index 00000000..70ad4a2f
--- /dev/null
+++ b/src/fsuae/fsuae-handler.h
@@ -0,0 +1,10 @@
+#ifndef FSUAE_HANDLER_H_
+#define FSUAE_HANDLER_H_
+
+#include "uae/types.h"
+#include "fsuae-externals.h"
+
+void SIGUSR1_handler(int signum);
+void fsuae_handlers_init(void);
+
+#endif  // FSUAE_HANDLER_H_
diff --git a/src/fsuae/fsuae-ini-exec.c b/src/fsuae/fsuae-ini-exec.c
new file mode 100644
index 00000000..479796e7
--- /dev/null
+++ b/src/fsuae/fsuae-ini-exec.c
@@ -0,0 +1,179 @@
+#define FSUAE_INTERNAL
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "fsuae-ini-exec.h"
+#include "fsuae-consts.h"
+#include "fsuae-externals.h"
+
+
+void _clean_line(char *line) {
+    // FIXME: implement better trim function
+    char buffer[MAX_LINE_LENGTH];
+    int line_length = strlen(line);
+
+    if (!line_length) {
+        return;
+    }
+
+    memset(buffer, 0, MAX_LINE_LENGTH);
+    strncpy(buffer, line, MAX_LINE_LENGTH);
+
+    if (buffer[line_length - 1] == '\n') {
+        buffer[line_length - 1] = 0;
+    }
+
+    line_length = strlen(buffer);
+
+    if (!line_length) {
+        return;
+    }
+
+    if (buffer[line_length - 1] == '\r') {
+        buffer[line_length - 1] = 0;
+    }
+
+    strncpy(line, buffer, MAX_LINE_LENGTH);
+}
+
+int _str_copy_from_char(char *str, char c, size_t maxlen) {
+    int char_at = 0;
+    char *pch;
+    char buffer[maxlen];
+
+    pch = strchr(str, c);
+
+    if (!pch) {
+        return 0;
+    }
+
+    char_at = pch - str + 1;
+
+    memset(buffer, 0, maxlen);
+    strncpy(buffer, &str[char_at], maxlen);
+    strncpy(str, buffer, maxlen);
+
+    return 1;
+}
+
+int _str_starts_with(const char *str, const char *pre) {
+    size_t lenpre = strlen(pre),
+           lenstr = strlen(str);
+    return lenstr < lenpre ? 0 : memcmp(pre, str, lenpre) == 0;
+}
+
+int _execute_command(char *command) {
+    char arguments[MAX_LINE_LENGTH];
+    char arg0[MAX_LINE_LENGTH];
+    char arg1[MAX_LINE_LENGTH];
+    char arg2[MAX_LINE_LENGTH];
+    char *ptr;
+    int ptr_index;
+
+    if (!strlen(command) || command[0] == '#') {
+        return 0;
+    }
+
+    if (strncmp(command, "cmd", 3) != 0) {
+        // skip not cmdX=
+        return 0;
+    }
+
+    printf("[%s] raw command: %s\n", APP_NAME, command);
+
+    if (!_str_copy_from_char(command, '=', MAX_LINE_LENGTH)) {
+        return 0;
+    }
+
+    printf("[%s] processed command: %s\n", APP_NAME, command);
+
+    if (_str_starts_with(command, "ext_disk_eject ")) {
+        if (!_str_copy_from_char(command, ' ', MAX_LINE_LENGTH)) {
+            return 0;
+        }
+
+        printf("[%s] processed command arguments: %s\n", APP_NAME, command);
+
+        strncpy(arguments, command, MAX_LINE_LENGTH);
+
+        _str_copy_from_char(arguments, ',', MAX_LINE_LENGTH);
+        strncpy(arg0, arguments, MAX_LINE_LENGTH);
+
+        ext_disk_eject(atoi(arg0));
+    }
+    else if (_str_starts_with(command, "ext_disk_insert_force ")) {
+        if (!_str_copy_from_char(command, ' ', MAX_LINE_LENGTH)) {
+            return 0;
+        }
+
+        printf("[%s] processed command arguments: %s\n", APP_NAME, command);
+
+        ptr = strtok(command, ",");
+        ptr_index = 0;
+
+        while (ptr != NULL) {
+            switch (ptr_index) {
+                case 0:
+                    strncpy(arg0, ptr, MAX_LINE_LENGTH);
+                    break;
+                case 1:
+                    strncpy(arg1, ptr, MAX_LINE_LENGTH);
+                    break;
+                case 2:
+                    strncpy(arg2, ptr, MAX_LINE_LENGTH);
+                    break;
+            }
+
+            ptr = strtok(NULL, ",");
+            ptr_index++;
+        }
+
+        ext_disk_insert_force(
+            atoi(arg0),
+            arg1,
+            atoi(arg2)
+        );
+    }
+
+    return 1;
+}
+
+int execute_ini_file(const char *pathname) {
+    FILE *file;
+    char line[MAX_LINE_LENGTH];
+    size_t line_length;
+    int commands_mode = 0;
+
+    file = fopen(pathname, "r");
+
+    if (!file) {
+        return 0;
+    }
+
+    while(fgets(line, MAX_LINE_LENGTH, file) != NULL) {
+        _clean_line(line);
+
+        if (!strncmp(line, "[commands]", MAX_LINE_LENGTH)) {
+            // commands
+            commands_mode = 1;
+
+            printf("[%s] executing temporary INI file commands\n", APP_NAME);
+
+            continue;
+        }
+        else if (line[0] == '[') {
+            commands_mode = 0;
+
+            continue;
+        }
+
+        if (commands_mode) {
+            _execute_command(line);
+        }
+    }
+
+    fclose(file);
+
+    return 1;
+}
diff --git a/src/fsuae/fsuae-ini-exec.h b/src/fsuae/fsuae-ini-exec.h
new file mode 100644
index 00000000..f94d1a1e
--- /dev/null
+++ b/src/fsuae/fsuae-ini-exec.h
@@ -0,0 +1,13 @@
+#ifndef FSUAE_INI_EXEC_H_
+#define FSUAE_INI_EXEC_H_
+
+#include <stdio.h>
+
+void _clean_line(char *line);
+int execute_ini_file(const char *pathname);
+int _execute_command(char *command);
+int _str_copy_from_char(char *str, char c, size_t maxlen);
+int _str_starts_with(const char *str, const char *pre);
+
+#endif  // FSUAE_INI_EXEC_H_
+
diff --git a/src/fsuae/fsuae-main.c b/src/fsuae/fsuae-main.c
index 21f84858..6017906a 100644
--- a/src/fsuae/fsuae-main.c
+++ b/src/fsuae/fsuae-main.c
@@ -61,6 +61,7 @@
 #include "fsemu-util.h"
 #include "fsemu-video.h"
 #include "fsemu-window.h"
+#include "fsuae-handler.h"
 
 #ifdef LINUX
 #include "../../fsemu/gamemode/lib/gamemode_client.h"
@@ -1872,6 +1873,8 @@ int main(int argc, char *argv[])
         fsemu_input_autofill_devices();
         fsemu_input_reconfigure();
         // FIXME: MOVE SOMEWHERE ELSE
+
+        fsuae_handlers_init();
     }
 
     const char *value = fs_config_get_const_string("whdload_quit_key");
diff --git a/src/od-fs/include/uae/uae.h b/src/od-fs/include/uae/uae.h
index 5bd9b24c..c2ce12cd 100644
--- a/src/od-fs/include/uae/uae.h
+++ b/src/od-fs/include/uae/uae.h
@@ -135,6 +135,9 @@ int amiga_floppy_get_drive_type(int index);
 int amiga_floppy_get_speed();
 int amiga_floppy_set_speed(int speed);
 
+void ext_disk_eject(int num);
+void ext_disk_insert_force(int num, const char *name, bool forcedwriteprotect);
+
 // FIMXE: REMOVE
 int amiga_floppy_set_from_list(int drive, int index);
 
diff --git a/src/od-fs/libamiga.cpp b/src/od-fs/libamiga.cpp
index 2d549ac6..6de91613 100644
--- a/src/od-fs/libamiga.cpp
+++ b/src/od-fs/libamiga.cpp
@@ -485,6 +485,14 @@ int amiga_get_num_floppy_drives()
     return 4;
 }
 
+void ext_disk_eject(int num) {
+    disk_eject(num);
+}
+
+void ext_disk_insert_force(int num, const char *name, bool forcedwriteprotect) {
+    disk_insert_force(num, name, forcedwriteprotect);
+}
+
 int amiga_floppy_set_from_list(int drive, int index)
 {
     write_log("insert floppy (%d) into drive (%d)\n", index, drive);
